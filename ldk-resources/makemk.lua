--
-- Copyright (C) 2025 Masatoshi Fukunaga
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy
-- of this software and associated documentation files (the "Software"), to deal
-- in the Software without restriction, including without limitation the rights
-- to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-- copies of the Software, and to permit persons to whom the Software is
-- furnished to do so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in
-- all copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
-- THE SOFTWARE.
--
-- This script generates a Makefile fragment for building C/C++ source files
-- in the src/ directory, grouping them by their prefixes.
--
-- PREFIX GROUPING RULES:
-- - Files are sorted by name length (shortest first)
-- - Longer filenames are checked against existing shorter names as prefixes
-- - If a prefix match is found, files are grouped into the same module
--
-- EXAMPLES:
--   src/foo.c, src/foo_bar.c, src/foo_baz.c
--   → Grouped into 'foo' module with all three files
--
--   src/bar.c, src/baz.c
--   → Separate modules: 'bar' and 'baz'
--
-- The script also handles both C and C++ files, ensuring that the correct
-- compiler and flags are used based on the file type.
--
local concat = table.concat
local sort = table.sort
local format = string.format
local stderr = io.stderr

local function printf(...) stderr:write(format(...), '\n') end

--- get the list of directories and files in src/
--- @param dirpath string the path to the directory to search
--- @return table a list of directories with their files
local function get_dirinfo(dirpath)
    local dirs = {}
    local command = format(
                        [[find %s -type f \( -name %s \) 2>/dev/null || true]],
                        dirpath, concat({'*.c', '*.cpp'}, ' -o -name '))

    for pathname in io.popen(command):lines() do
        -- split the file to dir, name
        local dirname, filename = pathname:match('^(.-)([^/]+)$')
        -- split the filename to name, ext
        local name, ext = filename:match('^([^%.]+)%.([^%.]+)$')

        local group = dirs[dirname]
        if not group then
            group = {dirname = dirname, names = {}, ext4name = {}}
            dirs[dirname] = group
            dirs[#dirs + 1] = group
        end
        group.names[#group.names + 1] = name
        if group.ext4name[name] then
            error(format(
                      'Cannot have the same filename %s.(%s|%s) in the same directory %s',
                      name, ext, group.ext4name[name], dirname))
        end
        group.ext4name[name] = ext
    end

    -- sort the directories by name
    sort(dirs, function(a, b) return a.dirname < b.dirname end)
    return dirs
end

--- add a file to a group based on its prefix
--- @param filegrp table the file group to add to
--- @param name string the name of the file to add
--- @param ext string the extension of the file to add
local function add_group(filegrp, name, ext)
    for gname, grp in pairs(filegrp) do
        -- if the file prefix matches the group name
        if #gname < #name and name:sub(1, #gname) == gname then
            -- add the file to the group
            grp.srcs[#grp.srcs + 1] = name .. '.' .. ext
            if ext == 'cpp' then
                grp.linker = '$(CXX)'
                grp.libs = '-lstdc++'
            end
            return
        end
    end

    -- create a new group for the file
    local grp = {srcs = {name .. '.' .. ext}, linker = '$(CC)', libs = ''}
    if ext == 'cpp' then
        grp.linker = '$(CXX)'
        grp.libs = '-lstdc++'
    end

    filegrp[name] = grp
end

printf(string.rep('#', 80))
printf('Generating mk/modules.mk...')

-- Create mk/ directory if it doesn't exist
local function mkdir_p(path)
    local cmd = format('mkdir -p "%s"', path)
    local res = os.execute(cmd)
    -- Lua 5.1 returns 0 on success, Lua 5.2+ returns true
    if res ~= true and res ~= 0 then
        error(format('Failed to create directory: %s', path))
    end
end

mkdir_p('mk')
printf('Opening mk/modules.mk for writing...')
local file, err = io.open('mk/modules.mk', 'w')
if not file then
    error(format('Failed to open mk/modules.mk for writing: %s', err))
end

file:write([[
# This file is generated by makemk.lua
# Do not edit this file directly.
# To regenerate this file, run `lua makemk.lua` from the project root.
# Generated on: ]] .. os.date('%Y-%m-%d %H:%M:%S') .. '\n\n')

local modules = {}
local dirinfo = get_dirinfo('src/')
--- group files by their prefixes in each directory
for _, dir in ipairs(dirinfo) do
    -- sort the names by length
    sort(dir.names, function(a, b) return #a < #b end)

    -- create a group for the files in the directory
    local filegrp = {}
    for _, name in ipairs(dir.names) do
        local ext = dir.ext4name[name]
        add_group(filegrp, name, ext)
    end

    -- foo_SRCS = src/foo1.c src/foo2.cpp
    -- foo_OBJS = $(foo_SRCS:.cpp=.o)
    -- foo_OBJS := $(foo_OBJS:.c=.o)
    -- foo_LINK = $(CXX)
    -- foo_LIBS = -lstdc++
    for gname, grp in pairs(filegrp) do
        local module_path = dir.dirname .. gname
        modules[#modules + 1] = module_path
        -- Convert path to variable name (src/foo/bar -> foo_bar)
        local var_name = module_path:gsub('^src/', ''):gsub('/', '_')
        local lines = ([[
@NAME@_SRC = @SRCS@
@NAME@_OBJS = $(@NAME@_SRC:.c=.o)
@NAME@_OBJS := $(@NAME@_OBJS:.cpp=.o)
@NAME@_LINK = @LINKER@
@NAME@_LIBS = @LIBS@]]):gsub('@([^@]+)@', {
            NAME = var_name,
            LINKER = grp.linker,
            LIBS = grp.libs,
            SRCS = dir.dirname .. concat(grp.srcs, ' ' .. dir.dirname)
        })
        printf('module: %s -> %s_* variables', module_path, var_name)
        file:write(lines, '\n\n')
    end
end
file:write(format('MODULES = %s', concat(modules, ' ')))
file:write('\n')
file:flush()
file:close()
printf('mk/modules.mk generated successfully.')
printf(string.rep('#', 80))
